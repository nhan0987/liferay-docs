---
header-id: what-is-service-builder
---

# サービスビルダーとは

<p class="alert alert-info"><span class="wysiwyg-color-blue120">ご覧のページは、お客様の利便性のために一部機械翻訳されています。また、ドキュメントは頻繁に更新が加えられており、翻訳は未完成の部分が含まれることをご了承ください。最新情報は都度公開されておりますため、必ず英語版をご参照ください。翻訳に問題がある場合は、<a href="mailto:support-content-jp@liferay.com">こちら</a>までご連絡ください。</span></p>

[TOC levels=1-4]

Liferay Service Builderは、エンティティと呼ばれるカスタムオブジェクトモデルを定義できるモデル駆動型のコード生成ツールです。 Service Builderは、オブジェクトモデルと基礎となるデータベースのコードを完全に分離するオブジェクトリレーショナルマッピング（ORM）テクノロジーを介してサービスレイヤーを生成します。 これにより、アプリケーションに必要なビジネスロジックを自由に追加できます。 Service BuilderはXMLファイルを入力として受け取り、アプリケーションに必要なモデル、永続性、およびサービスレイヤーを生成します。 これらの層は、懸念事項を明確に分離します。 Service Builderは、データベースの作成、読み取り、更新、削除、および検索の操作を実装するために必要なほとんどの共通コードを生成し、サービス設計のより高いレベルの側面に集中できるようにします。 このチュートリアルでは、Service Builderを使用する主な利点について説明します。

  - @product@との統合
  - 自動生成されたモデル、永続性、サービス層
  - 自動生成されたローカルおよびリモートサービス
  - 自動生成されたHibernateおよびSpring構成
  - エンティティーのファインダー・メソッドおよび許可を説明するファインダー・メソッドの生成のサポート
  - 組み込みのエンティティキャッシュのサポート
  - カスタムSQLクエリと動的クエリのサポート
  - 開発時間の節約

@product@は、Service Builderを使用して、内部データベース永続化コードをすべて生成します。 実際、ローカルおよびリモートの両方のサービスは、Service Builderによって生成されます。 さらに、サービス [モジュール](https://github.com/liferay/liferay-portal/tree/7.0.x/modules) はサービスビルダーによって生成されます。 これらのことは、Service Builderが堅牢で信頼できるツールであることを示しています。 使いやすく、保存することができます *多く* 開発時間のを。 Service Builderが生成するファイルの数は最初は恐ろしいように思えますが、アプリケーションをカスタマイズしてビジネスロジックを追加するには、いくつかのファイルを操作するだけで済みます。

| **注：** Service Builderを使用してアプリケーションを開発する必要はありません| @ \<product@\> カスタムコードを記述して開発することは完全に可能です。選択した持続性フレームワークを使用したデータベース持続性。 もしそうなら|選択すると、JPAまたはHibernateで直接作業できます。

Service Builderが開発時間を節約する主な方法の1つは、データベースアクセスコードを記述および保守する必要性を完全に排除することです。 基本的なサービスレイヤーを生成するには、 `service.xml` ファイルを作成してService Builderを実行するだけです。 これにより、プロジェクトの新しいサービス `.jar` ファイルが生成されます。 生成されたサービス `.jar` ファイルには、モデルレイヤー、永続化レイヤー、サービスレイヤー、および関連インフラストラクチャが含まれます。 これらの明確な層は、懸念の健全な分離を表しています。 モデル層は、プロジェクトのエンティティを表すオブジェクトの定義を担当し、永続層は、データベースへのエンティティの保存とデータベースからのエンティティの取得を担当し、サービス層は、エンティティとしてのCRUDおよび関連メソッドをAPIとして公開します。 Service Builderが生成するコードは、@product@自体と同様にデータベースに依存しません。

Service Builderが生成する各エンティティには、モデル実装クラスが含まれます。 各エンティティには、 `service.xml` ファイルでService Builderを構成する方法に応じて、ローカルサービス実装クラス、リモートサービス実装クラス、またはその両方も含まれます。 カスタマイズとビジネスロジックは、これら3つのクラスで実装できます。実際、これらはService Builderによって生成される、カスタマイズを目的とする唯一のクラスです。 すべてのカスタマイズが少数のクラスでのみ行われるようにすることで、Service Builderプロジェクトの保守が容易になります。 ローカルサービス実装クラスは、永続化レイヤーを呼び出してデータエンティティを取得および保存します。 ローカルサービスにはビジネスロジックが含まれ、永続層にアクセスします。 これらは、同じJava仮想マシンで実行されているクライアントコードによって呼び出すことができます。 通常、リモートサービスには権限チェック用の追加コードがあり、インターネットまたはローカルネットワーク経由でどこからでもアクセスできるようになっています。 Service Builderは、リモートサービスにアクセスできるようにするコードを自動的に生成します。 Service Builderが生成するリモートサービスにはSOAPユーティリティが含まれており、SOAPまたはJSON経由でアクセスできます。

Service Builderが開発時間を節約するもう1つの方法は、プロジェクトにSpringおよびHibernate構成を提供することです。 Service Builderは、Spring依存性注入を使用して、実行時にサービス実装クラスを使用可能にし、データベーストランザクション管理にSpring AOPを使用します。 Service Builderは、オブジェクトリレーショナルマッピングにHibernate永続フレームワークも使用します。 利便性のために、Service Builderはこれらのテクノロジーを使用する複雑さを隠しています。 SpringまたはHibernate環境を手動でセットアップしたり、構成を行ったりすることなく、プロジェクトで依存性注入（DI）、アスペクト指向プログラミング（AOP）、およびオブジェクトリレーショナルマッピング（ORM）を利用できます。

Service Builderを使用するもう1つの利点は、 *ファインダーメソッドを生成することです*。 Finderメソッドは、指定されたパラメーターに基づいてデータベースからエンティティオブジェクトを取得します。 `service.xml` 構成ファイルで生成されるファインダーメソッドの種類を指定するだけで、残りはService Builderが行います。 生成されたファインダメソッドを使用すると、たとえば、特定のサイトに関連付けられたすべてのエンティティのリスト、または特定のユーザーの特定のサイト *および* 関連付けられたすべてのエンティティのリストを取得できます。 Service Builderは、これらの種類の簡単なファインダーメソッドの生成だけでなく、Liferayの権限を考慮したファインダーメソッドの生成もサポートします。 たとえば、Liferayの権限システムを使用してエンティティへのアクセスを保護している場合、Service Builderは、ログインユーザーが表示する権限を持っているエンティティのみを返す別の種類のファインダーメソッドを生成できます。

Service Builderは、組み込みのキャッシュサポートも提供します。 3つのレベルでのLiferayキャッシュオブジェクト： *エンティティ*、 *ファインダ*、及び *休止*。 デフォルトでは、Liferayはこれらの各キャッシュレベルの基礎となるキャッシュプロバイダーとしてEhcacheを使用します。 ただし、これはポータルプロパティを介して構成できます。 プロジェクト内のエンティティのエンティティおよびファインダーのキャッシュを有効にするために必要なことは、 `service.xml` 構成ファイルでエンティティの `<entity>` 要素の `cache-enabled = true` 属性を設定することだけです。 Liferayキャッシングの詳細については、 [Liferay Clustering](/docs/7-1/deploy/-/knowledge_base/d/enabling-cluster-link) ドキュメントを参照してください。

Service Builderは柔軟なツールです。 データベースの永続化コードの作成に関連する一般的なタスクの多くを自動化しますが、カスタムSQLクエリまたはカスタムファインダーメソッドの作成を妨げることはありません。 Service Builderを使用すると、XMLファイルでカスタムSQLクエリを定義し、カスタムfinderメソッドを実装してクエリを実行できます。 これは、たとえば、SQL結合を介して複数のテーブルから特定の情報を取得する場合に便利です。 Service Builderは、動的クエリを介したデータベース情報の取得もサポートしています。 Liferayの動的クエリAPIは、Hibernateの基準APIを活用しています。

| **注**：Liferayには| [Service Builderライブラリ](https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.service.builder/) | |などのツール固有のプラグインをビルドします [Gradle Service Builderプラグイン](/docs/7-1/reference/-/knowledge_base/r/service-builder-gradle-plugin)、| LiferayのService Builderライブラリが依存関係として含まれています。 サービス| Builderは、Liferay 7のモジュール化されたアプリケーション開発スタイルの維持をサポートしています|別のモジュールのAPIおよび実装コード。 | [Service Builderサンプルアプリ](/docs/7-0/reference/-/knowledge_base/r/service-builder-samples) |これを示してください。

要約すると、Service Builderは@product@および@product@アプリケーション全体で使用される実証済みのソリューションであるため、アプリケーション開発にService Builderを使用することをお勧めします。 個別のモデル、永続性、サービスレイヤー、ローカルサービスとリモートサービス、SpringとHibernateの構成、および関連するインフラストラクチャを、手動による介入を必要とせずに生成します。 また、Liferayの権限を考慮して、基本的なSQLクエリと検索メソッド、および結果をフィルタリングするメソッドを生成できます。 Service Builderは、エンティティとクエリのキャッシュもサポートしています。 これらの各機能は、初期開発時間とプロジェクトの維持、拡張、またはカスタマイズに費やす必要がある時間の両方を大幅に短縮します。 最後に、Service Builderは制限的なツールではありません。カスタムSQLクエリとファインダーメソッドを追加でき、動的クエリもサポートします。
