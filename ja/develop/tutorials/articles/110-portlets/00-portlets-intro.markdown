---
header-id: portlets
---

# ポートレット

<p class="alert alert-info"><span class="wysiwyg-color-blue120">ご覧のページは、お客様の利便性のために一部機械翻訳されています。また、ドキュメントは頻繁に更新が加えられており、翻訳は未完成の部分が含まれることをご了承ください。最新情報は都度公開されておりますため、必ず英語版をご参照ください。翻訳に問題がある場合は、<a href="mailto:support-content-jp@liferay.com">こちら</a>までご連絡ください。</span></p>

[TOC levels=1-4]

@product@のWebアプリは *ポートレット*と呼ばれ* 。 多くのWebアプリと同様に、ポートレットは要求を処理し、応答を生成します。 応答では、ポートレットはブラウザで表示するためのコンテンツ（HTML、XHTMLなど）を返します。 ポートレットと他のWebアプリの大きな違いの1つは、ポートレットがWebページの一部で実行されることです。 ポートレットアプリケーションを作成するときは、そのアプリケーションについてのみ考慮する必要があります。ページの残りの部分（ナビゲーション、トップバナー、インターフェイスのその他のグローバルコンポーネント）は、他のコンポーネントによって処理されます。 もう1つの違いは、ポートレットはポータルサーバーでのみ実行されることです。 したがって、ポートレットは、ユーザー管理、認証、権限、ページ管理などのポータルの既存のサポートを使用できます。 これにより、ポートレットのコア機能の開発に集中できます。 多くの点で、アプリケーションをポートレットとして作成する方が、スタンドアロンアプリケーションを作成するよりも簡単です。</p>

ポートレットは、ユーザー（許可がある場合）またはポータル管理者がページに配置できます。ポータル管理者は、1つのページに複数の異なるポートレットを配置できます。 たとえば、コミュニティサイトのページには、コミュニティイベント用のカレンダーポートレット、重要なお知らせ用のお知らせポートレット、およびコミュニティに関心のあるリンク用のブックマークポートレットを含めることができます。 また、ポータルはページレイアウトを制御するため、ポートレットコードを変更することなく、ページ上の1つ以上のポートレットを再配置およびサイズ変更できます。 他の種類のWebアプリでこれをすべて実行するには、手動で再コーディングする必要があります。 あるいは、そのページで必要な唯一のアプリである場合、単一のポートレットでページ全体を占有することもできます。 たとえば、メッセージボードまたはwikiポートレットは、独自のページに最適です。 つまり、ポートレットは、Webアプリの開発に関連する従来の多くの問題点を軽減します。

![図1：複数のポートレットを1つのページに配置できます。](../../images/portlet-applications.png)

さらに、ポータルとポートレットは標準ベースです。 2003年、Java Portlet Specification 1.0（[JSR-168](https://jcp.org/en/jsr/detail?id=168)）が最初にポータルとポートレットの動作を定義しました。 2008年、Java Portlet Specification 2.0（[JSR-286](https://jcp.org/en/jsr/detail?id=286)）は、JSR-168を改良および構築し、下位互換性を維持しながら、ポートレット間通信（IPC）などの機能を定義しました。 最近リリースされたJava Portlet Specification 3.0（[JSR-362](https://jcp.org/en/jsr/detail?id=362)）は、ポータルとポートレットの進化を続けています。 Liferayは、エキスパートグループにメンバーを置くことでこの分野をリードしています。

では、これらの仕様は何を定義していますか？ 上記のリンクは完全な定義を示しています。ここでは、ポートレットが他のタイプのサーブレットベースのWebアプリとどのように異なるかを簡単に要約します。

ポートレットは、複数のフェーズでリクエストを処理します。 これにより、ポートレットはサーブレットよりもはるかに柔軟になります。 各ポートレットフェーズは、異なる操作を実行します。

  - **レンダリング：** ポートレットの現在の状態に基づいて、ポートレットのコンテンツを生成します。 このフェーズが1つのポートレットで実行されると、ページ上の他のすべてのポートレットでも実行されます。 レンダリングフェーズは、ページ上のポートレットがアクションフェーズまたはイベントフェーズを完了すると実行されます。
  - **アクション：** ユーザーアクションに応答して、アクションフェーズは、ポートレットの状態を変更するいくつかの操作を実行します。 アクションフェーズは、イベントフェーズによって処理されるイベントをトリガーすることもできます。 アクションフェーズとオプションのイベントフェーズに続いて、レンダリングフェーズはポートレットのコンテンツを再生成します。
  - **イベント：** アクションフェーズでトリガーされたイベントを処理します。 イベントはプロセス間通信（IPC）に使用されます。 ポートレットがすべてのイベントを処理すると、ポータルはページ上のすべてのポートレットでレンダリングフェーズを呼び出します。
  - **リソース提供：** ライフサイクルの残りの部分から独立したリソースを提供します。 これにより、ページ上のすべてのポートレットでレンダリングフェーズを実行することなく、ポートレットが動的コンテンツを提供できます。 リソース提供フェーズは、AJAXリクエストを処理します。

サーブレットと比較して、ポートレットには他にもいくつかの重要な違いがあります。 ポートレットが唯一ページの一部分をレンダリングするため、のようなタグ `<html>`、 `<head>`、及び `<body>` 許可されません。 また、事前にポートレットのページがわからないため、ポートレットURLを直接作成することはできません。 代わりに、ポートレットAPIは、プログラムでポートレットURLを作成するメソッドを提供します。 また、ポートレットは `javax.servlet.ServletRequest`に直接アクセスできないため、URLからクエリパラメーターを直接読み取ることはできません。 代わりに、ポートレットは `javax.portlet.PortletRequest` オブジェクトにアクセスします。 ポートレット仕様は、ポートレットが独自のURLパラメータまたはパブリックレンダリングパラメータとして宣言されたURLパラメータを読み取るためのメカニズムのみを提供します。 ただし、@product@は、 `ServletRequest` およびクエリパラメータにアクセスできるユーティリティメソッドを提供します。 ポートレットには、ポートレットライフサイクルの各フェーズで使用可能な *ポートレットフィルター* あります。 ポートレットフィルターは、要求と応答を即座に変更できるという点で、サーブレットフィルターに似ています。

また、ポートレットは、別個のモードとウィンドウ状態を持つことで、サーブレットとは異なります。 モードは、ポートレットの現在の機能を区別します。

  - **表示モード：** ポートレットの標準モード。 このモードを使用して、ポートレットの主な機能にアクセスします。
  - **編集モード：** ポートレットの構成モード。 このモードを使用して、カスタムビューまたは動作を構成します。 たとえば、天気ポートレットの編集モードでは、天気データを取得する場所を選択できます。
  - **ヘルプモード：** ポートレットのヘルプ情報を表示するモード。

最新のアプリケーションのほとんどは、表示モードのみを使用しています。

ポートレットウィンドウの状態は、ポートレットがページ上で占めるスペースの量を制御します。 ウィンドウ状態は、従来のデスクトップ環境のウィンドウの動作を模倣します。

  - **通常：** ポートレットは、他のポートレットを含むページに配置できます。 これがデフォルトのウィンドウ状態です。
  - **最大化：** ポートレットはページ全体を占有します。
  - **最小化：** ポートレットのタイトルバーのみが表示されます。

ポートレットを開発するとき、ポートレット仕様で定義されているすべての機能を活用できます。 ただし、ポートレットを開発およびパッケージ化する方法によっては、他のポータルコンテナで実行できない場合があります。 あなたは今、「ちょっと待って！ @product@は標準に準拠していると思いましたか？ @product@は標準に準拠していますが、開発者の生活を楽にするために設計されたAPIの形の甘味料が含まれています。 たとえば、@product@には [MVCフレームワーク](/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet) が含まれており、ポートレットにMVCを簡単に実装できます。 This framework, however, is only available in @<product@>. 変更しないと、このフレームワークを使用するポートレットは、Liferay以外のポータルコンテナにデプロイされた場合は実行されません。 ただし、MVCフレームワークまたは他の独自のAPIの使用を強制するものではないことに注意してください。 たとえば、厳密に標準に準拠したフレームワークとAPIを使用してポートレットを開発し、WARファイルにパッケージ化してから、標準に準拠したポータルコンテナにデプロイできます。

@product@にはOSGiランタイムも含まれています。 つまり、ポートレットを従来のWARファイルとして開発およびデプロイする必要はありません。代わりにOSGiモジュールとして行うことができます。 OSGiに固有のモジュール機能を活用できるように、後者をお勧めします。 これらの機能の詳細な説明については、チュートリアル [OSGiおよびModularity](/docs/7-1/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers)参照してください。 ただし、OSGiモジュールとして開発したポートレットは、OSGiランタイムを持たない他のポートレットコンテナでは実行されないことに注意してください。 それでも、モジュール性</a>

利点は非常に大きいため、ポートレットをOSGiモジュールとして開発することをお勧めします。</p> 

それでは、LiferayのフレームワークとAPIを採用するメリットは何ですか？ いくつかあります：

  - Liferayのデザインパターンに従います。 それらをよく理解すればするほど、@product@をよく理解できます。
  - これらは、ほぼ15年間のポートレット開発の結果です。
  - それらは、開発をより簡単かつ迅速にする多くの便利さを提供します。
  - これにより、アプリケーションはシステムの残りの部分により自然にフィットします。
  - 必要に応じて、標準に基づいて構築されているため、簡単に移行できます。

そうは言っても、さまざまなテクノロジーを使用してポートレットを開発できます。 このセクションでは、次のフレームワークと手法を使用してポートレットを開発する方法を示します。

  - [LiferayのMVCPortlet](/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet)
  - [Liferay Soy Portlet](/docs/7-1/tutorials/-/knowledge_base/t/liferay-soy-portlet)
  - [Spring MVC](/docs/7-1/tutorials/-/knowledge_base/t/spring-mvc)
  - [URLをより使いやすくする](/docs/7-1/tutorials/-/knowledge_base/t/making-urls-friendlier)
  - [自動単一ページアプリケーション](/docs/7-1/tutorials/-/knowledge_base/t/automatic-single-page-applications)
  - クレイスタイルをアプリに適用する
  - [ポートレット内でのレイアウトの作成](/docs/7-1/tutorials/-/knowledge_base/t/creating-layouts-inside-custom-portlets)
  - [JavaScript内部ポートレットの使用](/docs/7-1/tutorials/-/knowledge_base/t/using-javascript-in-your-portlets)

<!-- TODO: readd JSF link, when available. -Cody.
- [JSF Portlets with Liferay Faces](develop/tutorials/-/knowledge_base/7-1/jsf-portlets-with-liferay-faces)
-->



## 関連トピック

[依存関係の構成](/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies)

[パッケージのインポート](/docs/7-1/tutorials/-/knowledge_base/t/importing-packages)

[パッケージのエクスポート](/docs/7-1/tutorials/-/knowledge_base/t/exporting-packages)
