---
header-id: osgi-services-and-dependency-injection-with-declarative-services
---

# OSGiサービスと宣言型サービスによる依存性注入

<p class="alert alert-info"><span class="wysiwyg-color-blue120">ご覧のページは、お客様の利便性のために一部機械翻訳されています。また、ドキュメントは頻繁に更新が加えられており、翻訳は未完成の部分が含まれることをご了承ください。最新情報は都度公開されておりますため、必ず英語版をご参照ください。翻訳に問題がある場合は、<a href="mailto:support-content-jp@liferay.com">こちら</a>までご連絡ください。</span></p>

[TOC levels=1-4]

@product@では、OSGiフレームワークはオブジェクトを *サービス*として登録します。 各サービスは機能を提供し、他のサービスが提供する機能を活用できます。 OSGiサービスモデルは、オブジェクトのコラボレーション環境をサポートします。

宣言型サービス（DS）は、OSGiサービスの上にサービスコンポーネントモデルを提供します。 DSサービスコンポーネントには `@Component` アノテーションが付けられ、サービスクラスを実装または拡張します。 サービスコンポーネントは、互いのサービスを参照して使用できます。 Service Component Runtime（SCR）は、コンポーネントサービスを登録し、それらを参照する他のコンポーネントへのバインドを処理します。

「魔法」の仕組みは次のとおりです。

1.  **サービス登録：** サービスコンポーネントを含むモジュールをインストールすると、SCRはコンポーネントを指定されたサービスタイプに関連付けてサービスレジストリに保存するコンポーネント構成を作成します。

2.  **サービス参照処理：** サービスコンポーネントが別のサービスタイプを参照するモジュールをインストールすると、SCRはサービスタイプに一致するコンポーネント構成をレジストリで検索し、一致を見つけると、そのサービスのインスタンスを参照コンポーネントにバインドします。

最高の状態で公開、検索、バインドします！

DSを使用してサービスを登録およびバインドするにはどうすればよいですか？ XMLファイルの作成が含まれますか？ いいえ、それよりもはるかに簡単です。 `@Component` および `@Reference``つの注釈を使用します。</p>

<ul>
<li><p spaces-before="0"><a href="https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Component.html"><code>@Component`</a>：このアノテーションをクラス定義に追加して、クラスをコンポーネント（サービスプロバイダー）にします。</li>

  - [`@Reference`](ttps://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html)：この注釈をフィールドに追加して、フィールドのタイプに一致するサービスを注入します。</ul>

`@Component` アノテーションは、クラスをOSGiコンポーネントにします。 `サービス` プロパティを注釈内の特定のサービスタイプに設定すると、指定したサービスタイプによって他のコンポーネントがサービスコンポーネントを参照できます。

たとえば、次のクラスは、タイプ `SomeApi.class`サービスコンポーネントです。

    @Component(
        service = SomeApi.class
    )
    public class Service1 implements SomeApi {
    
       ...
    }

このクラスのモジュールをデプロイすると、SCRはクラスをサービスタイプ `SomeApi`関連付けるコンポーネント構成を作成します。

サービス参照の指定も簡単です。 `@Reference` 注釈をフィールドに適用すると、フィールドのタイプに一致するサービスが挿入されるようにマークされます。

    @Reference
    SomeApi _someApi;

このクラスのモジュールをデプロイすると、SCRはクラスタイプ `SomeApi` コンポーネント構成を検出し、この参照コンポーネントクラスにサービスをバインドします。

| **注：** `@Reference` 注釈は、次のクラスでのみ使用できます。 `@Component`注釈が付けられています。 つまり、宣言型サービスコンポーネントのみができます。 `@Reference` を使用して、OSGiサービスにバインドします。

[Liferayプロジェクトテンプレート](/docs/7-1/reference/-/knowledge_base/r/project-templates)から作成されたモジュールのビルド時に、bndは各モジュールのコンポーネント用に *コンポーネント記述* ファイルを自動的に作成します。 このファイルは、コンポーネントのサービス、依存関係、およびアクティベーション特性を指定します。 モジュールのデプロイ時に、OSGiフレームワークはコンポーネントの説明を読み取り、コンポーネントを作成し、他のコンポーネントへの依存関係を管理します。

SCRは、サービスコンポーネントを互いにペアリングする準備ができています。 参照元のコンポーネントごとに、SCRはターゲットサービスのインスタンスをそのコンポーネントにバインドします。

Springでの依存性注入の改善として、OSGi宣言サービスは動的な依存性注入をサポートします。 他のクラスが使用するサービスコンポーネントを作成および公開できます。 コンポーネントを更新し、サービスの代替コンポーネント実装を公開することもできます。 この種のダイナミズムは、@product@の強力な部分です。

|学習パスの一部としてこのチュートリアルにアクセスした場合| [Liferayポータル6から7.1](/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7)、次のトピックでできます：OSGi</a>での 動的展開。</p>
