---
header-id: benefits-of-liferay-7-for-liferay-6-developers
---

# Liferay Portal 6開発者にとっての7.1の利点

[TOC levels=1-4]

他のどのLiferayリリースよりも、@product-ver@は開発者に重点を置いています。 LiferayのプラットフォームはLiferay 7.0で再構築され、構築および保守が容易になったほか、以前のLiferayリリースよりも多くの新しい開発者機能を提供しています。

開発者にとってのこのリリースの主な利点は次のとおりです。

1.  **よりシンプルで効率的**

2.  **モジュラー開発パラダイム**

3.  **再利用性の強化**

4.  **拡張性が高く、メンテナンスが簡単**

5.  **選択したツールに最適化**

6.  **強力な構成可能性**

これらが開発をどのようにより簡単にするかを見ていきましょう。

## よりシンプルで効率的

独自の代替品と比較して、Liferayは常にシンプルで無駄がありません。 Liferay 7は、そこへさらに差をつけました。

Liferay 7は、合理化されたモジュラーアーキテクチャのおかげで、以前のバージョンよりもシンプルです。 さらに、拡張機能やアプリケーションを作成するLiferay固有の多くの方法が、公式または事実上の標準に従うように進化しました。 その結果、既存の知識をより簡単に再利用でき、Liferay向けに開発した学習内容をそれ以外でも応用できるようになりました。

Liferay 7もまた効率的です。 そのモジュール化されたコアにより、開発者およびシステム管理者は、不要な部分を削除できます。これにより、デプロイが容易になり、起動時間とメモリフットプリントが削減され、効率とパフォーマンスが向上します。

## モジュラー開発パラダイム

Liferayを使用している場合は、プラグインによってモジュラー開発の利点のいくつかをすでに経験しています。 @product-ver@は、これらの利点を完全に新たなレベルへ引き上げます。

すでに持っていたようなプラグインを構築することに加えて、[モジュール開発の実行とOSGi標準に基づくランタイムシステム](/docs/7-1/tutorials/-/knowledge_base/t/modularity-and-osgi)の利点を得ることができます。 @product-ver@は、モジュールを構成および再利用することにより、あらゆるタイプのアプリケーションの作成を容易にします。

モジュールは簡単に理解することができます。 モジュールはJARファイルとして配布されます。1つのJavaクラスと同等に小さくても、または考えられるアプリケーションと同等に大きくてもかまいません。 Liferayのアプリケーションは、単一のモジュールまたは必要な数のモジュールで構成できます。 優れた点は、モジュールは連携できるため、開発、デプロイ、保守、再利用しやすい小さな要素を組み合わせてアプリケーションを構築できることです。

## 再利用性の強化

Liferay上で大規模な開発に取り組んでいる場合、おそらく、あるプラグインのクラスのサブセットを別のプラグインと共有したいと思うような経験をしたことがあるでしょう。

Java EEはこれを実現するための標準的な方法を提供していませんが、LiferayはCLPというメカニズムで、それを実現する特定の機能を提供しました。CLPにはクラスローダー*magic*が使用され、Service Builderで作成された他のプラグインのサービスを、プラグインが呼び出すことを可能としています。 ただし、このメカニズムはいまだに少し制限があり（Java EEのクラスローダーではこれ以上認められていません）、あるモジュールから一部またはすべてのクラスを、別のモジュール内から使用するように指定するという自由が与えられません。

@product-ver@を使用すると、コードとランタイムメモリの両方で、いくつかの層を再利用できます。 再利用可能な任意の機能は、必要なおよびデプロイしたいクラスで[モジュールを作成](/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development#creating-a-module)（いくつかのメタデータを持つ単一JARファイルのみ）するだけです。 他のモジュールは、そのモジュール内でクラスを使用することを宣言するだけで（パッケージを指定する）、@product-ver@は自動的にそれらを結び付けます。 すべての呼び出しは、通常のJava呼び出しです。\ 実際に試してみてください。

このメカニズムは、厄介な「JAR/クラスパス」事象を排除します。 クラスパスにJARファイルを操作する必要も、複雑なクラスローダーを実装する必要もなくなりました。 ランタイム環境は、モジュールごとに個別のクラススペースを使用します。同じアプリケーションで複数のバージョンのライブラリを使用することもできます（共存できる場合）。

## 拡張性が高く、メンテナンスが簡単

Liferayの開発者に、お気に入りのLiferayの特性を尋ねると、最も人気のある上位3つの回答の1つに「拡張性の素晴らしさ」が挙げられます。 ほとんどすべての詳細をカスタマイズし、独自の機能を追加できます。

@product-ver@はさらに拡張可能です。   より多くの拡張ポイントが追加された だけでなく、すべての新しい拡張ポイントとアップグレードされた多くの既存の拡張ポイントは、OSGiのサービスモデルに基づいた新しい拡張メカニズムを使用します。 メカニズムの利点の一部を次に示します。

1.  **よりシンプル**：拡張ポイントの実装は、常にインターフェースを実装し、1つのアノテーション（`@Component`）を持つJavaクラスになりました。 以上のみで、とても簡単です。

2.  **メンテナンスが簡単**：拡張ポイントは、セマンティックバージョニングルールを使用するJavaインターフェイスを介してより厳密に定義されるようになりました。 つまり、特定の拡張機能APIに下位互換性がある限り、複数のLiferayバージョン間で変更を加えなくても拡張機能を使用できます。

3.  **動的**：拡張機能は、開発中または運用中にいつでもロードおよび削除できます。

しかし、それだけではありません。 独自の開発もこのモデルを活用して拡張可能になりました。 インターフェイスを作成し、セッターメソッドにアノテーション（`@Reference`）を注釈するだけで、簡単な拡張ポイントを作成できます。 拡張性の実装はかつてないほど容易になりました。

## 選択したツールに合わせて最適化

@product-ver@は、好きなツールの使用を可能にします。

強いこだわりがなく、私たちの提案を受け入れている場合は、[Liferay Workspace](/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace)を提供します。 Gradleとbndに基づいた、定評あるフォルダ構造とビルドシステムを提供します。 Liferay Workspaceは、コマンドラインまたはEclipseで実行される[Liferay @ide@](/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide)を経由して、スタンドアローンで使用できます。

[Maven](/docs/7-1/tutorials/-/knowledge_base/t/maven)などの特定のビルドツールに投資している場合、Liferayでの開発はこれまでになく簡単になります。 典型的なLiferay固有の開発タスク（Service Builderの使用など）用に[Mavenプラグイン](/docs/7-1/reference/-/knowledge_base/r/maven) を構築し、新しいアーキタイプのコレクションを提供しています。

プラグインSDKは@product-ver@で使用できなくなりました。 [Liferay Workspace](/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace)は現在、Liferayの定評ある開発環境です。 プラグインSDKをワークスペースに追加し、自分のペースでプロジェクトを移行することで、プラグインSDKから移行できます。 詳細については、記事[Using a Plugins SDK from Your Workspace](/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace#using-a-plugins-sdk-from-your-workspace)をご覧ください。

最後に、Liferayは[テンプレートから新しいプロジェクトを始める](/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli)ことを容易にする、[Blade CLI](/docs/7-1/tutorials/-/knowledge_base/t/blade-cli)と呼ばれる軽量なツールも開発しています。 -- それは特に、Mavenのアーキタイプ概念を持たないGradle向けに役立ちます。 Blade CLIは、サーバーを起動/停止し、モジュールをデプロイおよび管理するための[コマンド](/docs/7-1/tutorials/-/knowledge_base/t/blade-cli)も提供します。

## 強力な構成可能性

[構成可能なコード](/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications)は、@product-ver@で簡単に作成できます。 また、Liferayの新しい設定APIを使用するアプリケーションにより、管理者は[System Settings](/docs/7-1/user/-/knowledge_base/u/system-wide-settings)と呼ばれる自動生成されたユーザーインターフェイスを介して、その場で設定を変更できます。

これで、どのように@product-ver@が開発者エクスペリエンスを豊かにし、アプリケーションの開発やカスタマイゼーションを楽しくするかについてを理解できたと思います。

次に、OSGiとモジュラリティについて見ていき、重要な概念を議論し、モジュールを構築することがいかに簡単で満足のいくものであるかを示します。
