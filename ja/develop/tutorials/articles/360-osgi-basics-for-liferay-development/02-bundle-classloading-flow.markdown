---
header-id: bundle-classloading-flow
---

# バンドルクラスローディングフロー

<p class="alert alert-info"><span class="wysiwyg-color-blue120">ご覧のページは、お客様の利便性のために一部機械翻訳されています。また、ドキュメントは頻繁に更新が加えられており、翻訳は未完成の部分が含まれることをご了承ください。最新情報は都度公開されておりますため、必ず英語版をご参照ください。翻訳に問題がある場合は、<a href="mailto:support-content-jp@liferay.com">こちら</a>までご連絡ください。</span></p>

[TOC levels=1-4]

OSGiコンテナーは、インポートされたクラスを複数の場所で検索します。 見た目と順序を知ることが重要です。 OSGiバンドルの@product@のクラスローディングフローは、OSGiコア仕様に従います。 簡単ですが、複雑です。 以下の図はフローを示しており、このチュートリアルではそれを順を追って説明します。

![図1.0：このフローチャートは、バンドルでのクラスローディングを示しています。](../../images/bundle-classloading-flow-chart.png)

バンドル内のクラスローディングのアルゴリズムは次のとおりです。

1.  クラスが `java。*` パッケージにある場合、親クラスローダーにロードを委任します。 それ以外の場合は、続行します。

2.  クラスがOSGiフレームワークのブート委任リストにある場合は、ロードを親クラスローダーに委任します。 それ以外の場合は、続行します。

3.  バンドルが有線エクスポーターからインポートするパッケージの1つにクラスがある場合、エクスポートするバンドルのクラスローダーがそれをロードします。 *ワイヤードエクスポーター* は、以前にパッケージをロードした別のバンドルのクラスローダーです。 クラスが見つからない場合は、続行します。

4.  バンドルの必要なバンドルのいずれかによってクラスがインポートされた場合、必要なバンドルのクラスローダーがクラスをロードします。

5.  クラスがバンドルのクラスパス（マニフェストヘッダー `Bundle-ClassPath`）にある場合、バンドルのクラスローダーはそれをロードします。 それ以外の場合は、続行します。

6.  クラスがバンドルのフラグメントクラスパスにある場合、バンドルのクラスローダーはそれをロードします。

7.  クラスが `DynamicImport-Package` を使用して動的にインポートされるパッケージ内にあり、エクスポートバンドルとワイヤが確立されている場合、エクスポートバンドルのクラスローダーはそれをロードします。 それ以外の場合、クラスは見つかりません。

おめでとうございます！ これで、@product@がOSGiバンドルのクラスを見つけてロードする方法がわかりました。
